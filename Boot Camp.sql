-- select department_id, count(*)
-- AS total_employees
-- -- from HR.employees GROUP BY department_id;
---- Done 

 2. Find the average salary in each department
-- SELECT department_id, AVG(salary) AS avg_salary
-- FROM HR.employees
-- GROUP BY department_id;
-- ---- Done 
--  3. Find the maximum and minimum salary in each department
-- SELECT department_id, MAX(salary) AS max_salary, MIN(salary) AS min_salary
-- FROM HR.employees
-- GROUP BY department_id;
-- -- Done
-- SELECT department_id, SUM(salary) AS total_salary
-- FROM Hr.employees
-- GROUP BY department_id;
-- Done
-- SELECT job_id, COUNT(*) AS total_employees
-- FROM HR.employees
-- GROUP BY job_id;
-- Done
-- SELECT job_id, AVG(salary) AS avg_salary
-- FROM HR.employees
-- GROUP BY job_id;
-- Done
-- SELECT job_id, MAX(salary) AS max_salary
-- FROM HR.employees
-- GROUP BY job_id;
-- Done
-- SELECT job_id, MIN(salary) AS min_salary
-- FROM HR.employees
-- GROUP BY job_id;
-- Done 
-- SELECT job_id, SUM(salary) AS total_salary
-- FROM HR.employees
-- GROUP BY job_id;
-- Done
-- SELECT EXTRACT(YEAR FROM hire_date) AS hire_year, COUNT(*) AS total_employees
-- FROM HR.employees
-- GROUP BY EXTRACT(YEAR FROM hire_date)
-- ORDER BY hire_year;
-- Done
-- SELECT manager_id, COUNT(*) AS team_size
-- FROM HR.employees
-- WHERE manager_id IS NOT NULL
-- GROUP BY manager_id;
-- Done
-- SELECT manager_id, MAX(salary) AS max_salary
-- FROM HR.employees
-- WHERE manager_id IS NOT NULL
-- GROUP BY manager_id;
-- Done
-- SELECT manager_id, AVG(salary) AS avg_salary
-- FROM HR.employees
-- WHERE manager_id IS NOT NULL
-- GROUP BY manager_id;
-- Done
-- SELECT EXTRACT(MONTH FROM hire_date) AS hire_month, COUNT(*) AS total_hired
-- FROM HR.employees
-- GROUP BY EXTRACT(MONTH FROM hire_date)
-- ORDER BY hire_month;
-- Done
-- SELECT department_id, SUM(salary) AS total_salary
-- FROM HR.employees
-- GROUP BY department_id
-- ORDER BY total_salary DESC
-- FETCH FIRST 1 ROW ONLY;
-- Done
-- SELECT job_id, AVG(salary) AS avg_salary
-- FROM HR.employees
-- GROUP BY job_id
-- ORDER BY avg_salary DESC
-- FETCH FIRST 1 ROW ONLY;
-- Done
-- SELECT department_id, COUNT(*) AS employees_with_commission
-- FROM HR.employees
-- WHERE commission_pct IS NOT NULL
-- GROUP BY department_id;
-- Done
-- SELECT department_id, SUM(salary) AS total_salary_with_commission
-- FROM HR.employees
-- WHERE commission_pct IS NOT NULL
-- GROUP BY department_id;
-- Done



--  1. Find the total number of employees in each department.
--  Counts employees for each department using GROUP BY.
-- SELECT department_id, COUNT(*) AS total_employees
-- FROM HR.employees
-- GROUP BY department_id;
-- 2. Calculate the average salary in each department.
-- Computes the average salary for each department.
-- SELECT department_id, AVG(salary) AS avg_salary
-- FROM HR.employees
-- GROUP BY department_id;
-- 3. Find the department with the highest total salary.
-- Summarizes total salaries per department and selects the highest one.
-- SELECT department_id, SUM(salary) AS total_salary
-- FROM HR.employees
-- GROUP BY department_id
-- ORDER BY total_salary DESC
-- FETCH FIRST 1 ROW ONLY;
-- 4. Determine the highest and lowest salaries for each job role.
-- Finds the highest and lowest salary within each job role.
-- SELECT job_id, MAX(salary) AS max_salary, MIN(salary) AS min_salary
-- FROM HR.employees
-- GROUP BY job_id;
-- 5. Find the number of employees hired in each year.
-- Extracts year from hire_date and counts employees hired per year.
-- SELECT EXTRACT(YEAR FROM hire_date) AS hire_year, COUNT(*) AS total_employees
-- FROM HR.employees
-- GROUP BY EXTRACT(YEAR FROM hire_date)
-- ORDER BY hire_year;
-- 6. Assign a rank to employees based on their salary within each department.
-- Uses RANK() to assign ranks based on salary in each department.
-- SELECT department_id, employee_id, salary, 
--        RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS salary_rank
-- FROM employees;
-- 7. Find the top 3 highest-paid employees in each department.
-- Uses RANK() to rank employees based on salary and filters top 3.
-- SELECT department_id, employee_id, salary
-- FROM (
--     SELECT department_id, employee_id, salary, 
--            RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS salary_rank
--     FROM HR.employees
-- ) WHERE salary_rank <= 3;
-- 8. Identify the second highest salary in each department using DENSE_RANK().
-- Uses DENSE_RANK() to identify employees with the second-highest salary per department.
-- SELECT department_id, employee_id, salary
-- FROM (
--     SELECT department_id, employee_id, salary, 
--            DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS salary_rank
--     FROM HR.employees
-- ) WHERE salary_rank = 2;
-- 9. Compute the cumulative total salary of employees ordered by hire date.
-- Uses SUM() OVER() to create a running total of salaries.
-- SELECT employee_id, hire_date, salary, 
--        SUM(salary) OVER (ORDER BY hire_date) AS cumulative_salary
-- FROM HR.employees;
-- 10. Assign a row number to each employee in each department.
-- Uses ROW_NUMBER() to assign a unique row number per department.
-- SELECT department_id, employee_id, 
--        ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY employee_id) AS row_num
-- FROM HR.employees;
-- 11. Find the salary difference between each employee and the next highest-paid employee.
-- Uses LEAD() to compare an employee's salary with the next highest.
-- SELECT employee_id, salary, 
--        LEAD(salary) OVER (ORDER BY salary DESC) - salary AS salary_diff
-- FROM HR.employees;
-- 12. Calculate the previous month’s salary for each employee using LAG().
-- Uses LAG() to get the previous salary entry for each employee.
-- SELECT employee_id, salary, hire_date, 
--        LEAD(salary) OVER (PARTITION BY employee_id ORDER BY hire_date) AS prev_salary
-- FROM HR.employees;
-- 13. Identify employees whose salaries increased over time.
-- Uses LAG() to compare an employee's current and previous salaries.
-- SELECT employee_id, hire_date, salary, 
--        LAG(salary) OVER (PARTITION BY employee_id ORDER BY hire_date) AS prev_salary,
--        CASE WHEN salary > LAG(salary) OVER (PARTITION BY employee_id ORDER BY hire_date) 
--             THEN 'Increased' ELSE 'Decreased' END AS salary_trend
-- FROM HR.employees;
-- 14. Find the average salary of employees who joined in each year.
-- Computes average salary grouped by year of hire.
-- SELECT EXTRACT(YEAR FROM hire_date) AS hire_year, AVG(salary) AS avg_salary
-- FROM HR.employees
-- GROUP BY EXTRACT(YEAR FROM hire_date)
-- ORDER BY hire_year;
-- 15. Count the number of employees in each job role.
-- Counts employees for each job role using GROUP BY.
-- SELECT job_id, COUNT(*) AS total_employees
-- FROM HR.employees
-- GROUP BY job_id;
-- 16. Find the total salary expenditure for each manager's team.
-- Sums salaries of employees under each manager.
-- SELECT manager_id, SUM(salary) AS total_team_salary
-- FROM HR.employees
-- GROUP BY manager_id;
-- 17. Find the highest-paid employee in each department.
-- Uses RANK() to find the highest-paid employee in each department.
-- SELECT department_id, employee_id, salary
-- FROM (
--     SELECT department_id, employee_id, salary,
--            RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS salary_rank
--     FROM employees
-- ) WHERE salary_rank = 1;
-- 18. Calculate the running total of salaries for employees hired in each department.
-- Uses SUM() OVER() to compute cumulative salary totals.
-- SELECT department_id, employee_id, salary, 
--        SUM(salary) OVER (PARTITION BY department_id ORDER BY hire_date) AS running_total
-- FROM HR.employees;
-- 19. Find the employees who earn above the average salary of their department.
-- Uses a subquery to filter employees earning above department average.
-- SELECT employee_id, department_id, salary
-- FROM HR.employees e
-- WHERE salary >(SELECT AVG(salary) FROM HR.employees WHERE department_id = e.department_id);
-- 20. Rank employees within their department based on experience.
-- Uses RANK() to order employees by hire date per department.
-- SELECT employee_id, department_id, hire_date, 
--        RANK() OVER (PARTITION BY department_id ORDER BY hire_date ASC) AS experience_rank
-- FROM HR.employees;
-- 21. Find the difference between each employee’s salary and the department average.
-- Uses AVG() OVER() to compute salary difference from department average.
-- SELECT employee_id, department_id, salary, 
--        salary - AVG(salary) OVER (PARTITION BY department_id) AS salary_diff
-- FROM HR.employees;
-- 22. Find the department where the most employees have been hired.
-- Counts employees in each department and selects the highest.
-- SELECT department_id, COUNT(*) AS total_hired
-- FROM HR.employees
-- GROUP BY department_id
-- ORDER BY total_hired DESC
-- FETCH FIRST 1 ROW ONLY;
--  23. Identify employees who were hired in the same month and year as someone else.
-- Uses COUNT() OVER() to count employees hired in the same month-year.
-- SELECT employee_id, hire_date, 
--        COUNT(*) OVER (PARTITION BY EXTRACT(MONTH FROM hire_date), EXTRACT(YEAR FROM hire_date)) AS same_month_hires
-- FROM HR.employees;
-- 24. Calculate the moving average salary over the last 3 employees ordered by hire date.
-- Uses AVG() OVER() with ROWS BETWEEN for moving average calculation.
-- SELECT employee_id, hire_date, salary, 
--        AVG(salary) OVER (ORDER BY hire_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS moving_avg_salary
-- FROM HR.employees;
-- 25. Find employees whose salary is greater than that of the average of their manager’s team.
-- Uses a subquery to compare employee salary with manager's team average.
-- SELECT e.employee_id, e.manager_id, e.salary
-- FROM HR.employees e
-- WHERE e.salary > (SELECT AVG(salary) FROM HR.employees WHERE manager_id = e.manager_id);

sql joins

-- 1. Retrieve employee names and their department names using INNER JOIN
-- SELECT e.employee_id, e.first_name, d.department_name
-- FROM HR.employees e
-- INNER JOIN HR.departments d ON e.department_id = d.department_id;
-- 2. Retrieve all employees and their respective department names (including those without a department) using LEFT JOIN
-- SELECT e.employee_id, e.first_name, d.department_name
-- FROM HR.employees e
-- LEFT JOIN HR.departments d ON e.department_id = d.department_id;
-- 3. Retrieve all departments and employees (including departments without employees) using RIGHT JOIN
-- SELECT e.employee_id, e.First_name, d.department_name
-- FROM HR.employees e
-- RIGHT JOIN HR.departments d ON e.department_id = d.department_id;
-- 4. Retrieve all employees and their department names using FULL OUTER JOIN
-- SELECT e.employee_id, e.first_name, d.department_name
-- FROM HR.employees e
-- FULL OUTER JOIN HR.departments d ON e.department_id = d.department_id;
-- 5. Retrieve employees who do not belong to any department using LEFT JOIN with NULL check
-- SELECT e.employee_id, e.first_name
-- FROM HR.employees e
-- LEFT JOIN HR.departments d ON e.department_id = d.department_id
-- WHERE d.department_id IS NULL;
-- 6. Retrieve departments that have no employees using RIGHT JOIN with NULL check
-- SELECT d.department_id, d.department_name
-- FROM HR.employees e
-- RIGHT JOIN HR.departments d ON e.department_id = d.department_id
-- WHERE e.employee_id IS NULL;
-- 7. Retrieve employees along with their manager names using SELF JOIN
-- SELECT e.employee_id, e.First_name, m.First_name AS manager_name
-- FROM HR.employees e
-- LEFT JOIN HR.employees m ON e.manager_id = m.employee_id;
-- 8. Retrieve employees along with their job title using INNER JOIN
-- SELECT e.employee_id, e.First_name, j.job_title
-- FROM HR.employees e
-- INNER JOIN jobs j ON e.job_id = j.job_id;
-- 9. Retrieve employees along with the location of their department using INNER JOIN
-- SELECT e.employee_id, e.first_name, d.department_name, l.city
-- FROM HR.employees e
-- INNER JOIN departments d ON e.department_id = d.department_id
-- INNER JOIN locations l ON d.location_id = l.location_id;
-- 10. Retrieve employees and the projects they are assigned to using INNER JOIN
-- SELECT e.employee_id, e.employee_name, p.project_name
-- FROM employees e
-- INNER JOIN projects p ON e.employee_id = p.employee_id;
-- 11. Retrieve employees who have not been assigned to any project using LEFT JOIN
-- SELECT e.employee_id, e.employee_name
-- FROM employees e
-- LEFT JOIN projects p ON e.employee_id = p.employee_id
-- WHERE p.project_id IS NULL;
-- 12. Retrieve project names along with the department handling them using INNER JOIN
-- SELECT p.project_name, d.department_name
-- FROM projects p
-- INNER JOIN departments d ON p.department_id = d.department_id;
-- 13. Retrieve employees along with the names of their training programs using INNER JOIN
-- SELECT e.employee_id, e.employee_name, t.training_name
-- FROM employees e
-- INNER JOIN training_programs t ON e.training_id = t.training_id;
-- 14. Retrieve employees who have not attended any training programs using LEFT JOIN
-- SELECT e.employee_id, e.employee_name
-- FROM employees e
-- LEFT JOIN training_programs t ON e.training_id = t.training_id
-- WHERE t.training_id IS NULL;
-- 15. Retrieve employee names and their assigned shifts using INNER JOIN
-- SELECT e.employee_id, e.employee_name, s.shift_timing
-- FROM employees e
-- INNER JOIN shifts s ON e.shift_id = s.shift_id;
-- 16. Retrieve employees who do not have an assigned shift using LEFT JOIN
-- SELECT e.employee_id, e.employee_name
-- FROM employees e
-- LEFT JOIN shifts s ON e.shift_id = s.shift_id
-- WHERE s.shift_id IS NULL;
-- 17. Retrieve employees, their department names, and their assigned project names using multiple INNER JOINs
-- SELECT e.employee_id, e.employee_name, d.department_name, p.project_name
-- FROM employees e
-- INNER JOIN departments d ON e.department_id = d.department_id
-- INNER JOIN projects p ON e.employee_id = p.employee_id;
-- 18. Retrieve employees who have worked on more than one project using INNER JOIN and GROUP BY
-- SELECT e.employee_id, e.employee_name, COUNT(p.project_id) AS project_count
-- FROM employees e
-- INNER JOIN projects p ON e.employee_id = p.employee_id
-- GROUP BY e.employee_id, e.employee_name
-- HAVING COUNT(p.project_id) > 1;
-- 19. Retrieve employees along with their salaries and their department budget using INNER JOIN
-- SELECT e.employee_id, e.employee_name, e.salary, d.budget
-- FROM employees e
-- INNER JOIN departments d ON e.department_id = d.department_id;
-- 20. Retrieve employees who earn more than their department’s average salary using INNER JOIN and a subquery
-- SELECT e.employee_id, e.employee_name, e.salary
-- FROM employees e
-- INNER JOIN departments d ON e.department_id = d.department_id
-- WHERE e.salary > (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id);
-- 21. Retrieve employees who have the same job role as another employee using SELF JOIN
-- SELECT e1.employee_id, e1.employee_name, e2.employee_name AS coworker_name, e1.job_id
-- FROM employees e1
-- INNER JOIN employees e2 ON e1.job_id = e2.job_id AND e1.employee_id <> e2.employee_id;
-- 22. Retrieve employees and their department names, but show "Not Assigned" if an employee has no department using LEFT JOIN and COALESCE
-- SELECT e.employee_id, e.employee_name, COALESCE(d.department_name, 'Not Assigned') AS department_name
-- FROM employees e
-- LEFT JOIN departments d ON e.department_id = d.department_id;
-- 23. Retrieve employees and their assigned projects, including employees who are not assigned to any project using FULL OUTER JOIN
-- SELECT e.employee_id, e.employee_name, p.project_name
-- FROM employees e
-- FULL OUTER JOIN projects p ON e.employee_id = p.employee_id;
-- 24. Retrieve employees who work in a city where their department is located using INNER JOIN
-- SELECT e.employee_id, e.employee_name, l.city
-- FROM employees e
-- INNER JOIN departments d ON e.department_id = d.department_id
-- INNER JOIN locations l ON d.location_id = l.location_id;
-- 25. Retrieve employees and their total bonus amount using INNER JOIN with a bonus table
-- SELECT e.employee_id, e.employee_name, SUM(b.bonus_amount) AS total_bonus
-- FROM employees e
-- INNER JOIN bonuses b ON e.employee_id = b.employee_id
-- GROUP BY e.employee_id, e.employee_name;
-- 26. Retrieve employees who do not have any recorded bonuses using LEFT JOIN
-- SELECT e.employee_id, e.employee_name
-- FROM employees e
-- LEFT JOIN bonuses b ON e.employee_id = b.employee_id
-- WHERE b.bonus_amount IS NULL;
-- 27. Retrieve employees and their department names where employees belong to a specific region using INNER JOIN
-- SELECT e.employee_id, e.employee_name, d.department_name, r.region_name
-- FROM employees e
-- INNER JOIN departments d ON e.department_id = d.department_id
-- INNER JOIN locations l ON d.location_id = l.location_id
-- INNER JOIN regions r ON l.region_id = r.region_id;
-- 28. Retrieve employees and their project details, even if they are not assigned to a project using LEFT JOIN
-- SELECT e.employee_id, e.employee_name, p.project_name
-- FROM employees e
-- LEFT JOIN projects p ON e.employee_id = p.employee_id;
-- SELECT d.department_id, d.department_name, COUNT(e.employee_id) AS employee_count
-- FROM departments d
-- LEFT JOIN employees e ON d.department_id = e.department_id
-- GROUP BY d.department_id, d.department_name;
-- 29. Retrieve departments and the count of employees in each department using INNER JOIN and GROUP BY
-- SELECT d.department_id, d.department_name, COUNT(e.employee_id) AS employee_count
-- FROM departments d
-- LEFT JOIN employees e ON d.department_id = e.department_id
-- GROUP BY d.department_id, d.department_name;
-- 30. Retrieve employees who work on projects located in a different city than their department using INNER JOIN
-- SELECT e.employee_id, e.employee_name, d.department_name, p.project_name, l.city AS project_city
-- FROM employees e
-- INNER JOIN projects p ON e.employee_id = p.employee_id
-- INNER JOIN departments d ON e.department_id = d.department_id
-- INNER JOIN locations l ON p.location_id = l.location_id
-- WHERE d.location_id <> p.location_id;
PLSQL Examples
-- 1. Simple SELECT INTO Statement
--------------------------------------------------
-- DECLARE
--     emp_name VARCHAR2(50);
-- BEGIN
--     SELECT name INTO emp_name FROM employees WHERE id = 101;
--     DBMS_OUTPUT.PUT_LINE('Employee Name: ' || emp_name);
-- END;
-- 2. SELECT Multiple Columns INTO Variables
--------------------------------------------------
-- DECLARE
--     emp_name VARCHAR2(50);
--     emp_salary NUMBER;
-- BEGIN
--     SELECT name, salary INTO emp_name, emp_salary FROM employees WHERE id = 102;
--     DBMS_OUTPUT.PUT_LINE('Employee: ' || emp_name || ', Salary: ' || emp_salary);
-- END;

-- 3. Handling No Data Found Exception
--------------------------------------------------
-- DECLARE
--     emp_salary NUMBER;
-- BEGIN
--     BEGIN
--         SELECT salary INTO emp_salary FROM employees WHERE id = 999; -- Non-existing ID
--         DBMS_OUTPUT.PUT_LINE('Salary: ' || emp_salary);
--     EXCEPTION
--         WHEN NO_DATA_FOUND THEN
--             DBMS_OUTPUT.PUT_LINE('No employee found with this ID.');
--     END;
-- END;
-- 4. Using SELECT with CASE Statement
--------------------------------------------------
-- DECLARE
--     emp_status VARCHAR2(20);
-- BEGIN
--     SELECT 
--         CASE 
--             WHEN salary > 50000 THEN 'High Salary'
--             ELSE 'Low Salary'
--         END 
--     INTO emp_status 
--     FROM employees WHERE id = 103;
    
--     DBMS_OUTPUT.PUT_LINE('Employee Status: ' || emp_status);
-- END;
-- 5. Using COUNT() with SELECT INTO
--------------------------------------------------
-- DECLARE
--     total_employees NUMBER;
-- BEGIN
--     SELECT COUNT(*) INTO total_employees FROM employees;
--     DBMS_OUTPUT.PUT_LINE('Total Employees: ' || total_employees);
-- END;
-- 6. Fetching MAX Salary
--------------------------------------------------
-- DECLARE
--     max_salary NUMBER;
-- BEGIN
--     SELECT MAX(salary) INTO max_salary FROM employees;
--     DBMS_OUTPUT.PUT_LINE('Highest Salary: ' || max_salary);
-- END;
-- 7. Fetching MIN Salary
--------------------------------------------------
-- DECLARE
--     min_salary NUMBER;
-- BEGIN
--     SELECT MIN(salary) INTO min_salary FROM employees;
--     DBMS_OUTPUT.PUT_LINE('Lowest Salary: ' || min_salary);
-- END;
-- 8. Fetching AVG Salary
--------------------------------------------------
-- DECLARE
--     avg_salary NUMBER;
-- BEGIN
--     SELECT AVG(salary) INTO avg_salary FROM employees;
--     DBMS_OUTPUT.PUT_LINE('Average Salary: ' || avg_salary);
-- END;
-- 9. Fetching Employee Name Using Subquery
--------------------------------------------------
-- DECLARE
--     emp_name VARCHAR2(50);
-- BEGIN
--     SELECT name INTO emp_name FROM employees 
--     WHERE id = (SELECT MIN(id) FROM employees);
--     DBMS_OUTPUT.PUT_LINE('First Employee: ' || emp_name);
-- END;
-- 10. Fetching Data Using EXISTS
--------------------------------------------------
-- DECLARE
--     emp_exists VARCHAR2(10);
-- BEGIN
--     SELECT 
--         CASE 
--             WHEN EXISTS (SELECT 1 FROM employees WHERE id = 105) THEN 'Yes'
--             ELSE 'No'
--         END 
--     INTO emp_exists 
--     FROM dual;
    
--     DBMS_OUTPUT.PUT_LINE('Employee Exists: ' || emp_exists);
-- END;
-- 11. Selecting Employee with Highest Salary
--------------------------------------------------
-- DECLARE
--     emp_name VARCHAR2(50);
-- BEGIN
--     SELECT name INTO emp_name FROM employees 
--     WHERE salary = (SELECT MAX(salary) FROM employees);
--     DBMS_OUTPUT.PUT_LINE('Highest Paid Employee: ' || emp_name);
-- END;
-- 12. Fetching Department Name
--------------------------------------------------
-- DECLARE
--     dept_name VARCHAR2(50);
-- BEGIN
--     SELECT department_name INTO dept_name FROM departments WHERE department_id = 10;
--     DBMS_OUTPUT.PUT_LINE('Department: ' || dept_name);
-- END;
-- 13. Fetching Employee Count in a Department
--------------------------------------------------
-- DECLARE
--     emp_count NUMBER;
-- BEGIN
--     SELECT COUNT(*) INTO emp_count FROM employees WHERE department_id = 20;
--     DBMS_OUTPUT.PUT_LINE('Employees in Department 20: ' || emp_count);
-- END;
-- 14. Fetching Sum of All Salaries
--------------------------------------------------
-- DECLARE
--     total_salary NUMBER;
-- BEGIN
--     SELECT SUM(salary) INTO total_salary FROM employees;
--     DBMS_OUTPUT.PUT_LINE('Total Salaries: ' || total_salary);
-- END;
-- 15. Fetching Employee Joining Date
--------------------------------------------------
-- DECLARE
--     hire_date DATE;
-- BEGIN
--     SELECT hire_date INTO hire_date FROM employees WHERE id = 107;
--     DBMS_OUTPUT.PUT_LINE('Employee Hire Date: ' || hire_date);
-- END;
-- 16. Selecting Second Highest Salary
--------------------------------------------------
-- DECLARE
--     second_highest_salary NUMBER;
-- BEGIN
--     SELECT DISTINCT salary INTO second_highest_salary FROM employees 
--     WHERE salary < (SELECT MAX(salary) FROM employees) 
--     ORDER BY salary DESC FETCH FIRST 1 ROW ONLY;
    
--     DBMS_OUTPUT.PUT_LINE('Second Highest Salary: ' || second_highest_salary);
-- END;
-- 17. Selecting Employees with Same Salary as John
--------------------------------------------------
-- DECLARE
--     emp_count NUMBER;
-- BEGIN
--     SELECT COUNT(*) INTO emp_count FROM employees 
--     WHERE salary = (SELECT salary FROM employees WHERE name = 'John');
    
--     DBMS_OUTPUT.PUT_LINE('Employees with John''s Salary: ' || emp_count);
-- END;
-- 18. Fetching Manager Name of an Employee
--------------------------------------------------
-- DECLARE
--     manager_name VARCHAR2(50);
-- BEGIN
--     SELECT name INTO manager_name FROM employees WHERE id = 
--         (SELECT manager_id FROM employees WHERE id = 110);
    
--     DBMS_OUTPUT.PUT_LINE('Manager: ' || manager_name);
-- END;
-- 19. Fetching Number of Employees Who Earn Above Average Salary
--------------------------------------------------
-- DECLARE
--     count_above_avg NUMBER;
-- BEGIN
--     SELECT COUNT(*) INTO count_above_avg FROM employees 
--     WHERE salary > (SELECT AVG(salary) FROM employees);
    
--     DBMS_OUTPUT.PUT_LINE('Employees Earning Above Average: ' || count_above_avg);
-- END;
-- 20. Fetching Employee Name and Role
--------------------------------------------------
-- DECLARE
--     emp_name VARCHAR2(50);
--     emp_role VARCHAR2(50);
-- BEGIN
--     SELECT name, job_title INTO emp_name, emp_role FROM employees 
--     WHERE id = 112;
    
--     DBMS_OUTPUT.PUT_LINE('Employee: ' || emp_name || ', Role: ' || emp_role);
-- END;








